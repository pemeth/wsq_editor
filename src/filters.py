import numpy as np
from numpy.fft import fft2, ifft2, fftshift, ifftshift

from PIL import Image

import exceptions as e
from binarization import bradleyThreshold

def gaborFilter(im, orientim, freqim, mask, blocksize = 11):
    """Filter the input image `im` with a Gabor filter. The function return the filtered and binarized image, whcih is the same size as `im`.
    
    Parameters
    ----------
    im : numpy_array
        A 2D array holding the grayscale values of the input image.
    orientim : numpy_array
        A 2D array of the same size as `im` with the ridge orientations of the fingerprint image in radians.
    freqim : numpy_array
        A 2D array of the same size as `im` with the local ridge frequencies.
    mask : numpy_array
        A 2D array with the region of interest mask for the original image.
    blocksize : int
        A scalar specifying the kernel size of the Gabor filter.
        
    Returns
    -------
        A Gabor filtered and binarized image of the original fingerprint image of the same size as `im`."""
    if not isinstance(im, np.ndarray):
        raise e.InvalidDataType("The input image is not a numpy array.")
    if not isinstance(orientim, np.ndarray):
        raise e.InvalidDataType("The input orientation image is not a numpy array.")
    if not isinstance(freqim, np.ndarray):
        raise e.InvalidDataType("The input frequency image is not a numpy array.")
    if not isinstance(mask, np.ndarray):
        raise e.InvalidDataType("The input mask is not a numpy array.")

    if im.ndim != 2:
        raise e.InvalidInputImageDimensions("The input orientation image is not a 2D numpy array.")
    if orientim.ndim != 2:
        raise e.InvalidInputImageDimensions("The input image is not a 2D numpy array.")
    if freqim.ndim != 2:
        raise e.InvalidInputImageDimensions("The input frequency image is not a 2D numpy array.")
    if mask.ndim != 2:
        raise e.InvalidInputImageDimensions("The input frequency image is not a 2D numpy array.")

    if not isinstance(blocksize, int):
        raise e.InvalidDataType("The `blocksize` parameter is not an int or float.")

    filtered_im = np.zeros(im.shape)
    blockhalf = int(blocksize / 2)

    # precomputed tiled blocks for the `h()` gabor kernel generator,
    # so it doesn't need to generate new tiles during every function call
    x = np.arange(-blockhalf, blockhalf + 1)
    x = np.tile(x, (11, 1))
    y = np.arange(-blockhalf, blockhalf + 1).reshape((11, 1))
    y = np.tile(y, (1, 11))

    rows, cols = im.shape
    for r in range(blockhalf, rows-blockhalf):
        for c in range(blockhalf, cols-blockhalf):
            if mask[r,c] == False:
                continue
            phi = orientim[r,c]
            f = freqim[r,c]
        
            filtered_im[r,c] = np.sum( h(x, y, phi, f) * im[r-blockhalf:r+blockhalf+1,c-blockhalf:c+blockhalf+1] )

    filtered_im = bradleyThreshold(filtered_im, mask)
    return filtered_im

def h(x, y, phi, f):
    """A Gabor filter kernel generator, which returns a convolution kerner of the same size as the arrays `x` and `y`.
    
    Parameters
    ----------
    x, y : numpy_array
        Tiled 2D arrays. These should be generated by creating a 1D array of identically spaced values centered around 0 (e.g. -2,-1,0,1,2)
        and tiling them. The `x` and `y` parameters should be tiled vertically and horizontally, respectively. See tiling of these parameters
        in `gaborFilter()` as an example. `x` and `y` must be the same size.
    phi : int, float
        Orientation of the kernel in radians.
    f : float
        Frequency of the kernel.
        
    Returns
    -------
        A Gabor filter kernel of the same size as `x` and `y`."""
    x_phi = x * np.cos(phi) + y * np.sin(phi)
    y_phi = - x * np.sin(phi) + y * np.cos(phi)

    delta_x_squared = delta_y_squared = 16 # constants, here for readabiliy

    exp_arg = - 1/2 * ( (x_phi**2 / delta_x_squared) + (y_phi**2 / delta_y_squared) )

    kernel = np.exp(exp_arg) * np.cos(2 * np.pi * f * x_phi)

    return np.rot90(kernel) # it is a convolution kernel - rotate 90 degrees


def constructButter(size=100, D0=100, n=4):
    """Construct a 2D square butterworth filter.
    
    Parameters
    ----------
    size : int
        The size of the filter in both directions. Defaults to 100.
    D0 : int, float
        The cutoff frequecy. Defaults to 100.
    n : int
        Defines the steepness of the filter roll-off. If n is infinite, the output is an ideal filter. Defaults to 4.
        
    Returns
    -------
        A butterworth filter of size `size` in both directions with cutoff frequency `D0` and roll-off of `n`."""
    v = np.arange(-size//2, size//2).reshape((size, 1))
    v = np.tile(v, (1, size))
    u = np.arange(-size//2, size//2)
    u = np.tile(u, (size, 1))

    Duv = np.sqrt(u**2 + v**2)
    Huv = (1 / (1 + (Duv / D0)**(2*n)))

    return Huv

def butterworth(img):
    """Applies a Butterworth lowpass filter on the image `img`.
    
    Parameters
    ----------
    img : numpy_array
        The input image to be filtered.
        
    Returns
    -------
        The filtered image as a numpy array."""
    rows, cols = img.shape
    crow, ccol = rows // 2, cols // 2 # center row, center column

    # fast fourier transform of the image + shifting the low frequencies to the center
    fftImg = fftshift(fft2(img))

    # the filter size is bound by the lower of the width or height of the image - whichever is lower
    fsize = rows * (rows < cols) + cols * (cols <= rows)

    # construct a low pass filter of the same size as img and apply the filter
    butter = np.zeros_like(img, dtype=np.float32)
    butter[crow-fsize//2:crow+fsize//2, ccol-fsize//2:ccol+fsize//2] = constructButter(size=fsize)
    fftImg *= butter

    # inverse shift, inverse fft and returning only the real component
    fftImg = ifftshift(fftImg)
    img = np.real(ifft2(fftImg))

    return img