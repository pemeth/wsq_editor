import numpy as np

from PIL import Image

import exceptions as e

def gaborFilter(im, orientim, freqim, mask, blocksize = 11):
    """Filter the input image `im` with a Gabor filter. The function return the filtered and binarized image, whcih is the same size as `im`.
    
    Parameters
    ----------
    im : numpy_array
        A 2D array holding the grayscale values of the input image.
    orientim : numpy_array
        A 2D array of the same size as `im` with the ridge orientations of the fingerprint image in radians.
    freqim : numpy_array
        A 2D array of the same size as `im` with the local ridge frequencies.
    mask : numpy_array
        A 2D array with the region of interest mask for the original image.
    blocksize : int
        A scalar specifying the kernel size of the Gabor filter.
        
    Returns
    -------
        A Gabor filtered and binarized image of the original fingerprint image of the same size as `im`."""
    if not isinstance(im, np.ndarray):
        raise e.InvalidDataType("The input image is not a numpy array.")
    if not isinstance(orientim, np.ndarray):
        raise e.InvalidDataType("The input orientation image is not a numpy array.")
    if not isinstance(freqim, np.ndarray):
        raise e.InvalidDataType("The input frequency image is not a numpy array.")
    if not isinstance(mask, np.ndarray):
        raise e.InvalidDataType("The input mask is not a numpy array.")

    if im.ndim != 2:
        raise e.InvalidInputImageDimensions("The input orientation image is not a 2D numpy array.")
    if orientim.ndim != 2:
        raise e.InvalidInputImageDimensions("The input image is not a 2D numpy array.")
    if freqim.ndim != 2:
        raise e.InvalidInputImageDimensions("The input frequency image is not a 2D numpy array.")
    if mask.ndim != 2:
        raise e.InvalidInputImageDimensions("The input frequency image is not a 2D numpy array.")

    if not isinstance(blocksize, int):
        raise e.InvalidDataType("The `blocksize` parameter is not an int or float.")

    filtered_im = np.zeros(im.shape)
    blockhalf = int(blocksize / 2)

    # precomputed tiled blocks for the `h()` gabor kernel generator,
    # so it doesn't need to generate new tiles during every function call
    x = np.arange(-blockhalf, blockhalf + 1)
    x = np.tile(x, (11, 1))
    y = np.arange(-blockhalf, blockhalf + 1).reshape((11, 1))
    y = np.tile(y, (1, 11))

    rows, cols = im.shape
    for r in range(blockhalf, rows-blockhalf):
        for c in range(blockhalf, cols-blockhalf):
            if mask[r,c] == False:
                continue
            phi = orientim[r,c]
            f = freqim[r,c]
        
            filtered_im[r,c] = np.sum( h(x, y, phi, f) * im[r-blockhalf:r+blockhalf+1,c-blockhalf:c+blockhalf+1] )

    filtered_im = np.where(filtered_im > 0, True, False) # binarize
    return filtered_im

def h(x, y, phi, f):
    """A Gabor filter kernel generator, which returns a convolution kerner of the same size as the arrays `x` and `y`.
    
    Parameters
    ----------
    x, y : numpy_array
        Tiled 2D arrays. These should be generated by creating a 1D array of identically spaced values centered around 0 (e.g. -2,-1,0,1,2)
        and tiling them. The `x` and `y` parameters should be tiled vertically and horizontally, respectively. See tiling of these parameters
        in `gaborFilter()` as an example. `x` and `y` must be the same size.
    phi : int, float
        Orientation of the kernel in radians.
    f : float
        Frequency of the kernel.
        
    Returns
    -------
        A Gabor filter kernel of the same size as `x` and `y`."""
    x_phi = x * np.cos(phi) + y * np.sin(phi)
    y_phi = - x * np.sin(phi) + y * np.cos(phi)

    delta_x_squared = delta_y_squared = 16 # constants, here for readabiliy

    exp_arg = - 1/2 * ( (x_phi**2 / delta_x_squared) + (y_phi**2 / delta_y_squared) )

    kernel = np.exp(exp_arg) * np.cos(2 * np.pi * f * x_phi)

    return np.rot90(kernel) # it is a convolution kernel - rotate 90 degrees
